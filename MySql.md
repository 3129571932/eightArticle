# MySql

## 1.索引

### 	什么是索引

​		索引是一种数据结构，可以帮助mysql高效的获取数据。

### 	索引类型

​		B+树索引

​			按照算法把索引存入到b+树中，每次查询都是从根节点出发，遍历获取索引

​		hash索引

​			由于hash的特性，可以一次定位，效率高，但是对于范围查询，排序及组合索引依旧不高

​		全文索引

​			目前只有myisam引擎支持，只能在char，varchar，text类型的字段上创建

​		R树索引

### 	索引的种类

##### 		普通索引

​			可以包含重复的索引键值

​			适用于快速查找具有相同索引值的多个记录场景

​			不保证数据的唯一性

##### 		唯一索引

​			保证索引中的键值是唯一的

​			适用于确保表中某一列或者组合的唯一性

​			有效避免数据重复，保证数据的完整性

​			加快查询速度，尤其是等值查询

##### 		组合索引

​			为了应对多条件查询，所以创建组合索引，例如建立一个组合索引（a，b，c），实际上创建了a ab 			abc三个索引，如果创建一个abc索引然后执行 select a,b,c from table where a=1 and b=2 这种情			况是有覆盖索引的，索引列正好是要查询的数据，不需要回表查询

##### 		主键索引

​			一个表中只能有一个主键索引，是一个特殊的唯一索引，不允许有空值

##### 		全文索引

​			对于大量文本字段，使用like模糊匹配会造成性能下降，索引新增全文索引以此来提升性能

​			1.MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；	

​			2.MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;

​			3.只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

##### 		聚簇索引

​			聚簇索引一般指的就是主键索引，聚簇索引把数据和索引都存在b+树上，叶子节点存放数据，非叶			子节点存放索引键值

##### 		非聚簇索引

​			把数据和索引分开存储，节点包含索引字段值和只想数据页数据行的逻辑指针其行数量与数据表行			数据量一致。

### 	索引的原理

### InnoDB的索引和MyISAM的索引的区别

​	索引的存储方式不同，innodb采用b+树存储，索引和数据存在一起，而myisam数据和索引是分开存储的

### 如果一张表没有索引，还会创建b+树吗

​	会，会创建一个b+树，存储的是row_id，目的是合理的存储数据

### 二叉树，b树，b+树的区别，为什么选用b+树作为索引的数据结构

​	二叉树节点最多拥有两个叶子节点，所有的节点只能存储一个字段，左指针指向小于本节点的数，右指针指向大于本节点的数，二叉树的查找类似于二分法，但是极限情况下，二叉树有可能退化成链表，导致查询时间过长

​	b树相较于二叉树，每个节点可以有多个叶子节点

​	b+树相较于b树，非叶子节点只存储索引，且一个节点内可以有多个元素，叶子节点存储数据，叶子节点有指针链接，支持范围查询

由于b+树非叶子节点不存储数据，可以使IO次数减少，性能稳定，叶子节点相连，遍历更加方便

### 覆盖索引

​	就是把单列的非主键 索引 修改为多字段的联合索引,在一棵索引数上 就找到了想要的数据, 不需要去主键索引	树上,再检索一遍 这个现象,称之为 索引覆盖.

### 索引下推

​	索引下推实际上就是部分上层（服务层）负责的事情，交给了下层（引擎层）区域处理

### 回表

​	使用非聚簇索引，查到叶子节点的主键值，需要再次根据主键值去拿数据

### 索引失效

​	使用函数操作索引列，应该避免在索引列上使用函数

​	使用不等于（<>、!=）操作符：	

​	使用or的时候，两个字段不全都是索引列，可以使用union all或者建立联合索引

​		SELECT * FROM users WHERE age = 20 OR height = 180;

​		SELECT * FROM users WHERE age = 20

​		UNION ALL

​		SELECT * FROM users WHERE height = 180;

​	使用LIKE关键字进行模糊查询： 如果非要使用LIKE，尽量使用前缀索引。

​	使用类型转换：

​		SELECT * FROM users WHERE name = 1234;

​		确保查询条件的数据类型与列的数据类型一致。

​	使用复合索引而不把索引的第一个列用在条件中： 保证查询条件中有索引的第一列。

​	使用索引列进行运算：

​	使用不在索引中的列进行排序： 需要对排序字段建立索引	

### 最左匹配原则

​	最左匹配原理：

​		MySQL 建立多列索引（联合索引）有最左匹配的原则，即最左优先：

​		如果有一个 2 列的索引 (a, b)，则已经对 (a)、(a, b) 上建立了索引；

​		如果有一个 3 列索引 (a, b, c)，则已经对 (a)、(a, b)、(a, b, c) 上建立了索引；

​		在mysql根据查询条件遍历b+树的时候，会按照顺序先比较第一个索引，如a b c 索引，先比较a 然后b 最后c ，再比如bc索引，，先比较b然后比较c

## 2.数据库引擎

### 	InnoDB

​		支持ACID事务

​		行级锁

​		支持外键

​		崩溃恢复

​		高并发性能高（MVCC）

​		默认存储引擎

### 	MyISAM

​		表锁

​		支持全文索引

​		不支持事务

​		不支持外键

### 	Memory

### 	Archive

## 3.事务

### ACID

​	一致性

​		一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。一致性是通过原子性，隔离性， 持久性来保证的

​	原子性

​		一个事务包含多个sql语句，原子性是把一个事务看成一个sql，要么执行成功，要么执行失败，不能存在既执行成功有执行失败的状态，如果其中一条sql		执行失败，则所有sql需要回滚，回滚则依赖于undolog，此日志记录着insert delete update语句，如果回滚，则执行相反的语句，即可

​	隔离性

​		mysql事务并发，各个事务之间互相不影响

​	持久性

​		mysql为提升性能引入bufferpool缓冲池概念，缓冲池中包含部分数据页的映射，可以用来当成缓存，修改的时候，先写入bufferpool中，然后再写入磁		盘中，为了防止bufferpool中数据因mysql宕机丢失，写入的sql会在写入磁盘前记录到redolog中，mysql后台线程，每秒会把redolog日志文件写入到		page cache中，然后调用fsync同步到磁盘中

### 隔离级别和解决方案

##### 	读未提交：

​		事务并发时，a事务可以读到b事务没有提交的数据，这种情况下会产生脏读问题

##### 	读已提交：

​		事务a只能读到事务b提交过后的数据，没有提交的数据无法读取，可以防止脏读，但是会造成不可重复读（a事务读取数据的同时，其他事务对当前数据		修改并提交，导致不可重复读）

##### 	可重复读：

​		事务在读取 数据的时候，会锁定所涉及的数据，确保其他事务不能修改这些数据，可以防止脏读和不可重复读，但是会有幻读的情况发声（在当前事务		中，其他事务新增或者删除数据，导致幻读）

##### 	串行化：

​		事务按照先后顺序一个一个执行，性能低

### 当前读和快照读

##### 	当前读：

​		当前读获取的数据是最新数据，而且在读取时不能被其他修改的，所以会对读取的记录加锁来控制。

​		select * from table lock in share modle

​		select * from table for update

##### 	快照读：

​		快照读，顾名思义读取的是一份快照数据，所以读到的并不一定是最新数据，可能是历史数据。

### MVCC

​	mvcc主要是为了提升数据库的并发性能，在无锁的情况下也能处理并发读写问题，mysql只有innodb支持mvcc

​	MVCC主要解决了并发读写问题，降低死锁概率（使用乐观锁），解决快照读的问题

​	数据库表中有三个隐藏字短，包括 db_trx_id（对当前数据最后一次修改的事务id），db_roll_ptr（指向历史版本数据undolog），	idx(隐藏的主键id)，undolog，数据库会记录下update insert delete操作日志，以便回滚，readview（视图）

​	

### 锁

### 主从

### 集群