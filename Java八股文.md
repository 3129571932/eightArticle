### 1.面向对象

#### 	什么是面向对象

​		对比面向过程，是两种不同的处理问题的角度

​		面向过程更注重解决问题的每一个步骤及顺序，面向对象更注重解决问题有哪些参与者，及各自需要做什么

​		举例：	洗衣机洗衣服

​		面向过程会把该任务拆解成一系列步骤，1.打开洗衣机->2.放衣服->3.放洗衣粉->4.清洗

​		面向对象会拆分出人和洗衣机两个对象

​		人：打开洗衣机 	放衣服 	放洗衣粉

​		洗衣机：清洗 	烘干

​		总结： 面向过程比较直接，效率高，面向过程更易于服用，扩展和维护

#### 	封装

​		封装就是隐藏对象的属性和实现细节，仅对外提供公共方法，保护对象的数据不被修改，保证对象内部状态的安全性和完整性

##### 		封装的好处

​			提高安全性：内部实现被隐藏，防止外部直接访问修改内部属性，提高数据的安全性

​			简化接口：对外只公开接口，内部实现隐藏，代码简洁，易于理解使用

​			提高可维护性：内部实现被隐藏，修改方法时，只修改内部实现即可

​			实现代码复用：

#### 	继承

​		继承父类的属性和方法，并作出自己的扩展

##### 		继承的好处

​			代码复用：子类和继承父类的方法实现方法复用，减少代码量

​			扩展性：子类可在继承父类的基础上添加新的属性和方法，实现扩展

#### 	多态

​			多态是指一个对象在不同情况下可以表现出不同的行为，使得程序更加灵活，能应对各种情况，实现多态需要继承，重写父			类方法，父类的引用指向子类的实例

##### 			多态好处

​				代码简化：多态允许一个通用类型来处理不同的对象类型，从而减少代码

​				提高可扩展性：可以在不修改现有代码情况下，新增子类并使用多态来处理他们

### 2.JDK JRE JVM的区别

​	总结：JDK包含JRE和JVM，JRE包含JVM，JDK提供开发时的类库，JRE提供Java的运行环境，JVM时Java虚拟机，所有的Java程序都最		   终运行在jvm上面。

​	JDK：Java Development Kit，Java开发工具

​	JRE：Java Runtime Environment，Java运行时环境

​	JVM：Java Virtual Machine，Java虚拟机

### 3.==和equals

​	==对比的是栈中的值，对于基本类型变量，对比的是值是否相等，对于引用类型来说，对比的是堆中内存地址是否相等

​	equals在Object中默认采用 == 进行比较， 通常会重写

### 4.final

##### 	简述final的作用

​		final可以用来修饰 类，方法， 变量，当修饰类的时候，表示这个类不能被继承，修饰方法的时候，表明这个方法不能被重写，		修饰变量的时候，表明这个变量被能被修改

##### 	为什么局部内部类和匿名内部类只能访问局部final变量

​		1.生命周期差异：当一个方法被调用执行完毕后，该方法中的局部变量会被销毁，然而，局部内部类或者匿名内部类可能仍然存		在，因为他们在方法调用栈中创建的inner_Object不会随着方法的结束而销毁。如果局部变量不是final的，当方法执行完毕后，		内部类可能会访问不到已经不存在的局部变量，造成错误。

### 5.String StringBuffer StringBuilder区别和使用场景

##### 	1.String

​		String类是不可变的，也就是说，一旦创建一个Java的String对象，你就不能修改他，每次对String进行修改操作，实际上都会创		建一个新的对象，所以适用于字符串内容不会改变的场景，如常量或者配置

##### 	2.StringBuffer

​		StringBuffer类是可变的，提供了修改字符串内容的方法，如append，insert，delete，replace，等等

​		StringBuffer是线程安全的，底层提供的方法都加上synchronize修饰，由于有同步的开销，所以性能低

##### 	3.StringBuilder

​		和StringBuffer相同，只是没有线程同步，性能优于StringBuffer，适合不需要考虑线程安全和需要大量修改字符串的场景

### 6.重写和重载的区别

##### 	1.重写		

​		在同一个类中，可以对同一个方法进行重载，可以修改参数列表，实现逻辑，返回值类型实现净态多态性

​		是运行时的多态，通过对象的实际类型来调用相应的方法的

##### 	2.重载

​		子类继承父类的方法，子类可以重写父类的方法，子类只能修改实现逻辑，不能更改返回值类型，参数类型从而实现动态多态性

​		是编译时的多态性，根据调用时传入的参数类型，顺序和数量来确定调用那个方法

### 7.接口和抽象类

##### 	1.接口

​		使用interface进行修饰，在Java8之前，接口只能包含常量和抽象方法，Java8之后可以有默认方法和静态方法，一个类可以实现		多个接口

##### 	2.抽象类

​		使用abstract修饰的类，用于定义模版慧者规范，类中可以有抽象方法或者非抽象方法，子类只能单一继承一个父类，继承父类		后，必须为父类的抽象方法提供实现，除非子类也是抽象的，抽象类不能被实例化。

### 8.List和Set

##### 	区别

##### 	List

##### 	Set

### 9.HashCode和equals

##### 	1.HashCode

​		hashCode方法会返回对象的hash码，hash码的作用是返回该对象在hash表里的索引位置，hashCode相同只能说对象在hash		表中的索引位置相同，不能确定两者一定相等（hashcode相同代表hash冲突，hash冲突的对象挂载到相同的hash桶内）

##### 	2.equals	

​		略

### 10.ArrayList和LinkedList

#### 	ArrayList

​		底层由一个动态数组构成

​		初始化的时候，默认容量是10，在往list里面追加元素的时候，才会分配容量，添加的时候，会先判断容量是否足够，否则需要		进行扩容操作，容量为原来的1.5倍，新家一个1.5倍大小的数组，添加到新数组中，然后指向新数组。

​		删除的时候，找到要删除的元素后，后面的元素往前移一位即可

​		缩容：trimeToSize，缩容至当前数组元素大小，减少内存空间的浪费

#### 	LinkedList

​		底层由一个双向链表构成

​		直接往后面添加节点即可，无需扩容

​		遍历的时候从前往后开始遍历链表，o（n）

​	频繁在队尾添加删除元素，使用ArrayList，频繁在队中删除插入元素，使用LinkedList

### 11.HashMap

#### 		原理

​		在jdk1.7之前，hashmap底层是由一个数组+链表组成，在1.8时进行升级，升级成数组+链表（可升级成红黑树）

#### 	内部实现细节（1.8版本为准）

​		内部是由数组+链表+红黑树组成，hashmap的默认长度为16，负载因子为0.75

###### 		put过程：

​			首先，hashmap会根据key进行hash运算（），然后根据得到的hash值和hashmap的长度进行取模运算，得到的最终结果			就是该key-value在数组中的索引位置（下角标），如果该下角标已经有元素了，说明发生了hash碰撞，如果该下角标没有			元素，则直接放入该下角标中即可

​			hash碰撞处理：

​				如果发生了hash碰撞，（jdk1.8）处理的方法是，该下角标挂载一个链表，使用尾插法插入新值，如果链表的长度在				新插入值以后大于等于8，并且数组的长度大于64，则该链表会转化成红黑树，如果已经是红黑树，则直接插入红黑树				中

​			在插入完成后，hashmap会判断元素的数量是否大于阈值（hashmap默认大小*负载因子）[16 * 0.75]=12，如果大于12则			会触发扩容操作，扩容会新建一个长度为原来2倍的新数组，然后把老数组中的元素重新进行hash计算放入新数组中

​			如果插入已存在的key，则返回老的value，否则返回null

###### 		get过程：

​			同样，现根据key计算出hashcode，得到的值对当前hash长度取模，得到数组的下角标，如果该位置只有一个元素，直接			返回，如果有多个元素，说明发生hash碰撞，如果是链表，则遍历链表进行查找，红黑树也是遍历查找，查找成功则返			回，否则返回null

###### 		扩容过程：

#### 	是否是线程安全，解决方法

​		不是线程安全的，可以使用currentHashMap

### 12.异常体系

##### 	Throwable（所有的异常均继承此类）

​		Error：

​			代表程序无法处理的错误，一旦有这样的错误，程序会停止

​		Exception：

​			该类异常不会停止程序，分成runtimeException和CheckedException

​				OOM（内存溢出）

​			RuntimeException：会发生在程序运行的时候，会导致当前线程执行失败

​				NullPointerException

​				ClassCastException

​				ArrayOutOfIndexException

​			CheckedException：常常发生在程序编译期间，导致编译不通过

​				Java语法问题

### 	13.线程

##### 			线程的生命周期

​			1.新建

​				新创建一个线程对象

​			2.就绪

​				创建线程后，调用该线程的start方法，该线程就进入就绪状态，等待CPU的时间分片的获取

​			3.运行

​				线程获取到CPU的时间分片，进入到运行状态

​			4.阻塞

​				等待阻塞：运行的线程执行wait方法，该线程会释放所有资源，JVM会把该线程放入线程池中，进入这个状态后，时不						    能自动唤醒的，需要其他线程的notify或者notifyAll唤醒

​				同步阻塞：运行的线程获取对象同步锁的时候，若该锁被其他线程占用，该线程会进入锁池等待

​				其他阻塞：运行的线程执行sleep或者join方法，或者发出I/O请求JVM会把该线程置为阻塞状态，执行完后会重新进入						    就绪状态

​			5.死亡

​				线程运行完毕，或者发生异常直接终止

##### 			Sleep wait join yield区别

​			1.锁池

​				所有竞争锁资源失败的线程都会放到锁池里面，如果获取锁的线程释放锁后，会唤醒等待队列重新竞争锁

​			2.等待池

​				调用wait方法后，该线程就进入了等待池，等待池内不会尝试获取锁，只有调用notify或者是notifyAll之后，才会唤醒				线程去锁池竞争锁，notify是随机唤醒一个锁，notifyAll是全部唤醒

​				1.sleep：这是Thread类的一个静态方法，用于使当前线程暂停执行一段时间，让其他线程有机会继续执行。它并不会				释放对象锁，因此在synchronized同步块中，其他线程仍然不能访问共享数据。sleep()方法需要捕捉异常，并且时间				到后会自动恢复执行，无需其他线程的唤醒。

​				2.wait：这是Object类的一个方法，它会使当前线程等待，直到其他线程调用该对象的notify或notifyAll方法。与sleep				不同的是，wait会释放对象锁，将线程从锁池转到等待池。因此，其他线程可以在等待线程被唤醒之前访问共享数				据。wait必须与synchronized配套使用，因为它需要在获取对象锁的前提下进行。

​				3.yield：这是Thread类的一个静态方法，用于提示调度器当前线程愿意放弃对CPU的占用，以使其他线程得到执行的				机会。然而，yield并不能保证当前线程会立即停止执行，而是使其进入到就绪状态，重新参与CPU的竞争。也就是				说，有可能在yield之后，仍然是该线程获取到CPU并执行。

​				4.join：这是Thread类的一个方法，用于让当前线程等待另一个线程结束后再继续执行。当调用一个线程的join方法				时，当前线程会进入阻塞状态，直到被join的线程执行结束。这种方式常用于确保主线程在所有子线程都完成工作后再				结束。

##### 线程池		

###### 	什么是线程池：

​		线程池的基本思想就是一种对象池，在程序启动的时候，就开辟一块内存空间，里面放入众多线程，线程池中的线程是由池管理		器来进行调度，当有线程任务的时候，从池中选取一个线程去执行任务，执行完后线程再次放入线程池中，避免线程的重复创建		和销毁，节省系统资源

###### 	使用线程池的好处：

​		减少线程的创建和销毁，线程可以被重复利用，可以执行多个任务。

​		运用线程池能有效的控制最大并发数，可以根据系统的承受能力，调用池中的线程，防止因并发过高导致的内存被占满

​		可以对线程进行一些简单的管理，比如延时执行，定时循环执行等等

###### 	线程池的主要组件：

​		线程池管理器：用于创建线程池，包括创建线程池，销毁线程池，添加新任务。

​		工作线程：线程池中的线程，在没有任务时处于等待状态，可以重复利用

​		任务接口：每个任务必须实现的接口，以供线程调度任务的执行

​		任务队列：用于存放没有处理的任务，提供一种缓冲机制

###### 	线程池的核心参数：

​		corePoolSize：核心线程数线程池中维护的最小的一个线程数量，即使这些线程处于空闲状态，那也不会销毁，除非设置了					   allowCoreThreadTimeout

​		maximumPoolSize：最大线程数，线程池所能容纳的最大的线程数量，当活跃线程数达到该数值后，后续的新任务会被阻塞

​		KeepAliveTime：线程池内线程最长空闲时间，一旦超过这个时间，并且当前线程数高于corePoolSize的值，会销毁空闲线程

​		unit：时间单位

​		workQueue：新任务被提交后，会先进入这个队列等待，等待任务调度时才出队执行，采用的是阻塞队列

​		threadFactory：线程工厂，用于定制线程对象的创建，例如设置线程名字，是否是守护线程

​		handler：拒绝策略，当线程池的线程达到maximumPoolSize后，workQueue满了，且当前没有空闲线程，新任务进来后会触				  发拒绝策略

​				AbortPolicy：默认的拒绝策略，线程数量达到max无空闲且workqueue满了，新任务提交后会抛出		         

​							rejectExecutionException

​				CallerRunsPolicy：调用者运行策略，线程数量达到max无空闲且workqueue满了，新任务会提交给调用execute的线								  程执行，适合不允许失败的情况

​				DiscardPolicy：丢弃策略，当达到上述条件，直接丢弃新任务，并且不会抛出异常

​				DiscardOldestPolicy：弃老策略，达到上述条件后，慧丢弃等待时间最长的任务，并尝试提交新任务，如果线程池被								       关闭，则新任务会被丢弃

###### 	线程池类型：

​		FixedThreadPool（制定大小的线程池）

​			线程池内的线程数量固定，即使空闲也不会背回收，当无空闲线程时，新任务会等待

​		ScheduledThreadPool（定时线程池）

​			支持定时或者周期性的执行任务，每个任务都关联一个延时时间，或者周期时间

​			适用于定时任务

​		SingleThreadExecutor（单线程）

​			只有一个线程，所有的任务都会被按照提交顺序执行

​			适合任务之间有关联性的场景

​		CachedThreadPool（可缓存的线程池）

​			线程数量不固定，当提交新任务时，如果线程池中有空闲的线程会立即执行，否则创建一个新线程来执行任务，空闲线程会			在一定时间内销毁，减少资源消耗

​			适用于执行段时间内大量的任务，如用户请求

​		ForkJoinPool

​			Java7引入的一个可以并行拆解任务的线程池，他使用分而治之的策略并行处理大规模计算任务。

​			适用于可以拆解子任务的情况。

# JVM

### 一个类是什么时候被加载的

​	在《Java虚拟机规》中并没有进行强制约束，交由虚拟机自己掌控，hotspot中是按需加载，在需要用到这个类的时候才会加载。

### jvm中一个类的加载过程

​	一个类加载到jvm内存中，需要经历7个阶段

​		1.加载

​			把classpath， jar包， 网络 ，或者磁盘下的某个class文件二进制字节流读进来，在内存中生成一个代表这个类的			Java.lang.Class对象放入元空间，此阶段我们可以通过自定义类加载器进行干预。

​		2.验证

​			验证class文件中是否符合《Java虚拟机规范》的全部要求，保证虚拟机的安全

​		3.准备

​			类的变量赋默认初始值，int为0，long为0L，boolean为false，引用类型为null，常量正常赋值

​		4.解析

​			把符号引用翻译成直接引用

​		5.初始化

​			当我们new一个对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射对一个类进行调			用，初始化当前类，那么这些都会触发初始化。

​		6.使用

​			使用这个类

​		7.卸载

​			这个类的所有实例都被GC回收

​			加载该类的classLoader被GC

​			该类的在其他类中没有引用	

### jvm中一个类的初始化过程

​	静态成员的初始化

​		静态成员包括静态变量和静态代码块，他们属于类的本身，随着类的初始化而优先被加载。

​		父类中的静态变量和静态代码块

​		子类的静态变量和静态代码块

​		静态成员只加载一次

​	非静态成员初始化

​		非静态成员包含普通变量，普通代码块，一般会在类进行实例话的时候加载

​		父类中的普通成员和普通代码块，然后是构造方法

​		子类中的普通成员和普通代码块，然后是构造方法

### JVM内存模型

##### 	JVM内存模型

​		堆：

​			堆是OOM故障的主要发源地，堆中存储着几乎所有的实例对象，堆由垃圾回收器自动回收，堆区由各个子线程共享使用，			通常情况下，它占用的空间是内存区域中最大的，但是如果无节制的创建对象，会很容易的消耗完所有空间，堆的空间可以			指定大小，也可以运行时动态调整，通过参数 -Xms -Xmx来指定大小。

​		方法区：

​			方法区是所有线程共享的区域，用来存储已被虚拟机加载的类的信息，常量，静态变量，JIT（just in time及时编译技术）			编译后的代码数据，运行时常量池是方法区的一部分区域用于存放编译期间生成的各种字面常量和富豪引用。

​		虚拟机栈：

​			这是一个线程私有的区域，它描述的是Java方法执行的内存模型，每个方法运行的同时，都会创建一个栈帧，栈帧中存储着			局部变量，操作数栈，方法出口等信息。每个方法从调用到完成都对应着栈帧的入栈和出栈。每当方法运行结束后，jvm会			把栈帧出栈的元素当成返回值返回。

​		本地方法栈：

​			本地方法栈和虚拟机栈的作用是相同的，不同的是，本地方法栈只为虚拟机使用到的Native方法执行

​		程序计数器：

​			程序计数器是一块较小堆内存区域，是线程私有的，在多线程环境中，每个线程都有一个程序计数器，用于指示当前线程执			行的字节码地址

### 堆的内存结构划分

​	分为年轻代和老年代，年轻代：老年代 = 1：2

##### 		年轻代：

​			Eden：s0：s1 = 8：1：1

##### 		老年代：	

### 对象的创建过程

​	加载类：通过类的全限定名获取类的二进制字节流，将二进制字节流转换为运行时数据结构，即在方法区创建该类的class对象，作			为方法区该类的入口

​	验证：验证类是否符合JVM规范，确保不会危害JVM

​	准备：为静态变量分配内存并设置类变量的默认值和初始值，

​	解析：将类中的符号引用转换为直接引用，符号引用是编译器生成的，二直接引用和虚拟机的布局有关

​	初始化：为类的静态变量赋予正确的初始值，初始化阶段会在创建类的实例，访问静态变量，调用静态方法，执行反射时触发

### 	类加载器

​		BootStrapClassLoader

​			是ExtClassLoader的父类加载器，负责加载%JAVA_HOME%/lib下的jar包和class文件

​		ExtClassLoader

​			是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext下的jar包和class文件

​		AppClassLoader

​			是自定义加载器的父类加载器，加载classPath下面的类文件

​		可以继承classLoader实现自定义加载器

### 	双亲委托模型

​		从App->Ext->BootStrap从下到上，找缓存，如果已经有加载器加载过该类，则不用加载

​		从bootStrap->Ext->App从上到下找的是加载路径，找到就加载，否则就包找不到类

##### 		好处：

​			安全性， 避免用户自己写的类，替换Java核心类，比如String

​			同时也避免了类的重复加载因为JVM中区分不同类，不仅仅是通过类名相同的class文件被不同的classLoader加载过后就是			不同的类

### 可以打破双亲委托模型吗，怎么做

​	可以，重新定义一个类加载器，重写loadClass方法，使其不进行双亲委派即可

### ClassLoader中loadClass，findClass，defineClass的区别

​	loadClass主要就是进行类加载的方法，其中双亲委派就在这个方法中

​	findClass根据名称或者位置加载class字节码

​	defineClass把字节码转换成class

​	当我们想要自定义一个类加载器，并且想打破双亲模型，需要重写loadClass方法

​	当我们想要自定义一个类加载器，但是不想打破双亲委派模型，可以重写findClass方法，findClass方法之抛出一个异常，没有默认	实现

​	如果想不打破双亲委派模型，且实现自己的类加载器逻辑，可以把相关逻辑方法findClass中即可

### 加载一个类使用Class.forName和classLoader有什么区别

​	Class.ForName得到的class是已经初始化完成的

​	ClassLoader.loaderClass得到的class是没有初始化的

### TomCat类加载的机制

​	在jvm类加载器的基础上，tomcat新增了3个基础类加载器和每个web应用加载器和一个jsp类加载器

### 为什么Tomcat要打破双亲委派模型

​	tomcat是一个web容器，那么一个web容器可能会部署多个应用

###### 			部署在同一个tomcat中的应用所使用的Java类库应该要相互隔离

​			A用的是spring4的jar包， B用的是spring5的jar包，如果没有打破双亲委派，只会加载一遍jar包（可能加载4的也可能是5			的），导致有个应用依赖的jar包不对，打破后，每个wen应用都有自己的类加载器，都加载自己的jar包

###### 			部署在同一个tomcat中的应用所使用的Java类库应该要相互共享

​			一些版本相同的jar包可以共享，比如json，jdbc。。。。

###### 			保证tomcat服务器自身的安全不受部署web应用程序的影响

​			tomcat的类加载器加载tomcat需要的类，web应用的类加载器加载web应用需要的类，不要相互打扰

###### 			需要支持jsp页面的热部署和热加载

​			tomcat支持jsp热加载，只需要替换原来的jsp后，tomcat就会启动一个新的类加载器重新加载jsp

### 说一下对象完整的创建流程

### 对象内存分配时的指针碰撞和空闲列表机制

### 对象头

### 如何计算对象占用内存大小

### 对象指针压缩

### 解释下对象栈上分配，逃逸分析标量替换

### 什么样的类能被回收

### CMS垃圾收集器收集过程

### CMS比较严重的问题，并发收集阶段再次触发Full GC怎么处理

### 垃圾收集底层三色标记法

### 对象漏标的处理方案 增量更新与原始快照

### G1的垃圾收集过程

### G1垃圾收集最大停顿时间如何实现的

### 什么是内存泄露，如何排查

### GC是什么时候都能做的吗，GC安全点和安全区域

### 字符串常量池

### 八种基本类型的包装类常量池如何实现的

### 热加载和热部署

##### 	热加载

​		在不重启服务的情况下，使得修改的代码生效，热加载可以显著提升开发调试效率，但是不安全，不会上生产

​		如何实现：

​			实现自己的类加载器

​			从自己的类加载器中加载需要热加载的类

​			不断轮询需要热加载的类，判断class是否有更新，如果有更新，重新加载

##### 	热部署

​		在不重启服务的情况下，重新部署整个项目，tomcat就是热部署，如果修改war包内容，tomcat就会删除之前的war包，重新生		成一个新的war包

### GC垃圾回收算法

##### 	引用计数器法

​		每个对象个都有一个引用计数器，当对象被引用，计数器加1，引用结束，计数器减1，为0的时候，就可以被回收

​		优点是简单，缺点是无法处理循环引用

##### 	标记清除算法

​		先把存活的对象标记出来，然后删除垃圾对象，缺点是容易导致出现内存碎片，效率低

##### 	复制算法

​		把内存区域划分成两部分，每次只用一半，把存活的对象移到另一边即可，不会出现内存碎片，缺点是内存使用率低

##### 	标记压缩

​		在经过标记后，把存活的对象移动到一端，然后以存活的分界线直接丢弃另一端的垃圾对象，优点是解决了内存碎片的问题，提		高内存的使用率，缺点是需要移动对象，增加性能开销

##### 	分代回收

​		根据年轻代和老年代的对象存活以及GC特点，年轻代使用复制算法，老年代使用标记压缩算法

##### 	增量式垃圾回收

​		用户线程和垃圾线程交替执行，减少STW（stop the word）导致的停顿时间，该算法适用于对与性能要求较高的系统

### GC垃圾收集器

##### 	串行垃圾收集器

​		在收集垃圾时，暂停所有用户线程，直到收集完成

​		适用于单线程环境或者系统规模较小

##### 	并行垃圾收集器

​		使用多线程并行进行垃圾回收，但是用户线程依然被暂停

​		适用于多核CPU，可以缩短垃圾回收时间

##### 	并发标记-清除收集器

​		在垃圾收集过程中，用户线程和垃圾回收线程可以并发执行，减少STW时间

​		适用于对系统响应时间有一定要求的系统

##### 	G1收集器（Garbage first）

​		将对内存划分多个大小相同的区域，优先收集垃圾最多的区域，尽可能满足应用的停顿时间要求

##### 	ZGC收集器

​		实现低延迟的垃圾收集器，几乎不产生停顿

​		对实时性能要求特别高，游戏或者实时交易系统

##### 	Shenandoah收集器

​		基于标记-压缩算法，设计用于降低停顿时间，支持并发和并行操作

​		大规模，高吞吐系统

##### 	Epslion收集器

​		不执行任何垃圾收集，如果对堆存满了，直接停止应用

​		适用于某些性能测试

### 	GC如何判断对象可以被回收

​		引用计数法

​			每个对象都有一个计数器，如果被引用一次，则计数器加一，引用释放则计数器减一，如果计数器为0，代表可以被回收

​			如果a引用b，b又引用a，则引用无法被释放，不可被回收

​		可达性分析法

​			从GC Root向下搜索，搜索走过的路径称之为引用链，如果一个对象到GC Root没有任何引用链，则证明此对象是没有用			的，可回收

​			GC Root对象有：

​				虚拟机栈中引用的对象

​				方法区中静态属性引用的对象

​				方法区中常量引用的对象

​				本地方法栈中引用的对象

​				被可达性分析标记的可回收对象拥有一次不被回收的机会，对象被回收需要经过两次标记，第一次是GC Root可达性分				析标记出没有引用链，第二次是由虚拟机栈自动建立的Finalizer队列中判断是否执行finalize方法

​				当对象不可达时，GC会判断当前对象是否覆盖finalize方法，没有覆盖就会被回收，覆盖了，否则，判断兑现过是否执				行过finalize 方法没执行过，就放入F-queue队列，由低优先级的线程执行该队列中的finalize方法执行完后，GC再次				判断队列中的对象是否可达，不可达会被回收，否则不会回收。

# Spring

### 	如何定义一个IOC容器

​		1.配置包的扫描路径

​		2.递归包扫描获取.class文件

​		3.反射，确定需要交给IOC的类

​		4.对需要进行依赖注入的类进行依赖注入

​			配置文件中指定需要扫描包的路径

​			定义一些注解，分别表示控制层，业务层，数据持久层，依赖注入注解，获取配置文件注解

​			从配置文件中获取扫描包的路径，获取当前路径下的所有.class文件，把当前所有.class文件放入Set集合中

​			遍历这个Set集合，获取在类上有指定注解的类，并交给IOC容器，定义一个安全的map来存储这些对象

​			遍历这个IOC容器，获取每一个类的实例，判断是否有依赖注入，如果有，就进行依赖注入