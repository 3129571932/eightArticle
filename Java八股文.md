### 1.面向对象

#### 	什么是面向对象

​		对比面向过程，是两种不同的处理问题的角度

​		面向过程更注重解决问题的每一个步骤及顺序，面向对象更注重解决问题有哪些参与者，及各自需要做什么

​		举例：	洗衣机洗衣服

​		面向过程会把该任务拆解成一系列步骤，1.打开洗衣机->2.放衣服->3.放洗衣粉->4.清洗

​		面向对象会拆分出人和洗衣机两个对象

​		人：打开洗衣机 	放衣服 	放洗衣粉

​		洗衣机：清洗 	烘干

​		总结： 面向过程比较直接，效率高，面向过程更易于服用，扩展和维护

#### 	封装

​		封装就是隐藏对象的属性和实现细节，仅对外提供公共方法，保护对象的数据不被修改，保证对象内部状态的安全性和完整性

##### 		封装的好处

​			提高安全性：内部实现被隐藏，防止外部直接访问修改内部属性，提高数据的安全性

​			简化接口：对外只公开接口，内部实现隐藏，代码简洁，易于理解使用

​			提高可维护性：内部实现被隐藏，修改方法时，只修改内部实现即可

​			实现代码复用：

#### 	继承

​		继承父类的属性和方法，并作出自己的扩展

##### 		继承的好处

​			代码复用：子类和继承父类的方法实现方法复用，减少代码量

​			扩展性：子类可在继承父类的基础上添加新的属性和方法，实现扩展

#### 	多态

​			多态是指一个对象在不同情况下可以表现出不同的行为，使得程序更加灵活，能应对各种情况，实现多态需要继承，重写父			类方法，父类的引用指向子类的实例

##### 			多态好处

​				代码简化：多态允许一个通用类型来处理不同的对象类型，从而减少代码

​				提高可扩展性：可以在不修改现有代码情况下，新增子类并使用多态来处理他们

### 2.JDK JRE JVM的区别

​	总结：JDK包含JRE和JVM，JRE包含JVM，JDK提供开发时的类库，JRE提供Java的运行环境，JVM时Java虚拟机，所有的Java程序都最		   终运行在jvm上面。

​	JDK：Java Development Kit，Java开发工具

​	JRE：Java Runtime Environment，Java运行时环境

​	JVM：Java Virtual Machine，Java虚拟机

### 3.==和equals

​	==对比的是栈中的值，对于基本类型变量，对比的是值是否相等，对于引用类型来说，对比的是堆中内存地址是否相等

​	equals在Object中默认采用 == 进行比较， 通常会重写

### 4.final

##### 	简述final的作用

​		final可以用来修饰 类，方法， 变量，当修饰类的时候，表示这个类不能被继承，修饰方法的时候，表明这个方法不能被重写，		修饰变量的时候，表明这个变量被能被修改

##### 	为什么局部内部类和匿名内部类只能访问局部final变量

​		1.生命周期差异：当一个方法被调用执行完毕后，该方法中的局部变量会被销毁，然而，局部内部类或者匿名内部类可能仍然存		在，因为他们在方法调用栈中创建的inner_Object不会随着方法的结束而销毁。如果局部变量不是final的，当方法执行完毕后，		内部类可能会访问不到已经不存在的局部变量，造成错误。

### 5.String StringBuffer StringBuilder区别和使用场景

##### 	1.String

​		String类是不可变的，也就是说，一旦创建一个Java的String对象，你就不能修改他，每次对String进行修改操作，实际上都会创		建一个新的对象，所以适用于字符串内容不会改变的场景，如常量或者配置

##### 	2.StringBuffer

​		StringBuffer类是可变的，提供了修改字符串内容的方法，如append，insert，delete，replace，等等

​		StringBuffer是线程安全的，底层提供的方法都加上synchronize修饰，由于有同步的开销，所以性能低

##### 	3.StringBuilder

​		和StringBuffer相同，只是没有线程同步，性能优于StringBuffer，适合不需要考虑线程安全和需要大量修改字符串的场景

### 6.重写和重载的区别

##### 	1.重写		

​		在同一个类中，可以对同一个方法进行重载，可以修改参数列表，实现逻辑，返回值类型实现净态多态性

​		是运行时的多态，通过对象的实际类型来调用相应的方法的

##### 	2.重载

​		子类继承父类的方法，子类可以重写父类的方法，子类只能修改实现逻辑，不能更改返回值类型，参数类型从而实现动态多态性

​		是编译时的多态性，根据调用时传入的参数类型，顺序和数量来确定调用那个方法

### 7.接口和抽象类

##### 	1.接口

​		使用interface进行修饰，在Java8之前，接口只能包含常量和抽象方法，Java8之后可以有默认方法和静态方法，一个类可以实现		多个接口

##### 	2.抽象类

​		使用abstract修饰的类，用于定义模版慧者规范，类中可以有抽象方法或者非抽象方法，子类只能单一继承一个父类，继承父类		后，必须为父类的抽象方法提供实现，除非子类也是抽象的，抽象类不能被实例化。

### 8.List和Set

##### 	区别

##### 	List

##### 	Set

### 9.HashCode和equals

##### 	1.HashCode

​		hashCode方法会返回对象的hash码，hash码的作用是返回该对象在hash表里的索引位置，hashCode相同只能说对象在hash		表中的索引位置相同，不能确定两者一定相等（hashcode相同代表hash冲突，hash冲突的对象挂载到相同的hash桶内）

##### 	2.equals	

​		略

### 10.ArrayList和LinkedList

#### 	ArrayList

​		底层由一个动态数组构成

​		初始化的时候，默认容量是10，在往list里面追加元素的时候，才会分配容量，添加的时候，会先判断容量是否足够，否则需要		进行扩容操作，容量为原来的1.5倍，新家一个1.5倍大小的数组，添加到新数组中，然后指向新数组。

​		删除的时候，找到要删除的元素后，后面的元素往前移一位即可

​		缩容：trimeToSize，缩容至当前数组元素大小，减少内存空间的浪费

#### 	LinkedList

​		底层由一个双向链表构成

​		直接往后面添加节点即可，无需扩容

​		遍历的时候从前往后开始遍历链表，o（n）

​	频繁在队尾添加删除元素，使用ArrayList，频繁在队中删除插入元素，使用LinkedList

### 11.HashMap

#### 		原理

​		在jdk1.7之前，hashmap底层是由一个数组+链表组成，在1.8时进行升级，升级成数组+链表（可升级成红黑树）

#### 	内部实现细节（1.8版本为准）

​		内部是由数组+链表+红黑树组成，hashmap的默认长度为16，负载因子为0.75

###### 		put过程：

​			首先，hashmap会根据key进行hash运算（），然后根据得到的hash值和hashmap的长度进行取模运算，得到的最终结果			就是该key-value在数组中的索引位置（下角标），如果该下角标已经有元素了，说明发生了hash碰撞，如果该下角标没有			元素，则直接放入该下角标中即可

​			hash碰撞处理：

​				如果发生了hash碰撞，（jdk1.8）处理的方法是，该下角标挂载一个链表，使用尾插法插入新值，如果链表的长度在				新插入值以后大于等于8，并且数组的长度大于64，则该链表会转化成红黑树，如果已经是红黑树，则直接插入红黑树				中

​			在插入完成后，hashmap会判断元素的数量是否大于阈值（hashmap默认大小*负载因子）[16 * 0.75]=12，如果大于12则			会触发扩容操作，扩容会新建一个长度为原来2倍的新数组，然后把老数组中的元素重新进行hash计算放入新数组中

​			如果插入已存在的key，则返回老的value，否则返回null

###### 		get过程：

​			同样，现根据key计算出hashcode，得到的值对当前hash长度取模，得到数组的下角标，如果该位置只有一个元素，直接			返回，如果有多个元素，说明发生hash碰撞，如果是链表，则遍历链表进行查找，红黑树也是遍历查找，查找成功则返			回，否则返回null

###### 		扩容过程：

#### 	是否是线程安全，解决方法

​		不是线程安全的，可以使用currentHashMap

### 12.异常体系

##### 	Throwable（所有的异常均继承此类）

​		Error：

​			代表程序无法处理的错误，一旦有这样的错误，程序会停止

​		Exception：

​			该类异常不会停止程序，分成runtimeException和CheckedException

​				OOM（内存溢出）

​			RuntimeException：会发生在程序运行的时候，会导致当前线程执行失败

​				NullPointerException

​				ClassCastException

​				ArrayOutOfIndexException

​			CheckedException：常常发生在程序编译期间，导致编译不通过

​				Java语法问题

### 	13.线程

##### 			线程的生命周期

​			1.新建

​				新创建一个线程对象

​			2.就绪

​				创建线程后，调用该线程的start方法，该线程就进入就绪状态，等待CPU的时间分片的获取

​			3.运行

​				线程获取到CPU的时间分片，进入到运行状态

​			4.阻塞

​				等待阻塞：运行的线程执行wait方法，该线程会释放所有资源，JVM会把该线程放入线程池中，进入这个状态后，时不						    能自动唤醒的，需要其他线程的notify或者notifyAll唤醒

​				同步阻塞：运行的线程获取对象同步锁的时候，若该锁被其他线程占用，该线程会进入锁池等待

​				其他阻塞：运行的线程执行sleep或者join方法，或者发出I/O请求JVM会把该线程置为阻塞状态，执行完后会重新进入						    就绪状态

​			5.死亡

​				线程运行完毕，或者发生异常直接终止

##### 			Sleep wait join yield区别

​			1.锁池

​				所有竞争锁资源失败的线程都会放到锁池里面，如果获取锁的线程释放锁后，会唤醒等待队列重新竞争锁

​			2.等待池

​				调用wait方法后，该线程就进入了等待池，等待池内不会尝试获取锁，只有调用notify或者是notifyAll之后，才会唤醒				线程去锁池竞争锁，notify是随机唤醒一个锁，notifyAll是全部唤醒

​				1.sleep：这是Thread类的一个静态方法，用于使当前线程暂停执行一段时间，让其他线程有机会继续执行。它并不会				释放对象锁，因此在synchronized同步块中，其他线程仍然不能访问共享数据。sleep()方法需要捕捉异常，并且时间				到后会自动恢复执行，无需其他线程的唤醒。

​				2.wait：这是Object类的一个方法，它会使当前线程等待，直到其他线程调用该对象的notify或notifyAll方法。与sleep				不同的是，wait会释放对象锁，将线程从锁池转到等待池。因此，其他线程可以在等待线程被唤醒之前访问共享数				据。wait必须与synchronized配套使用，因为它需要在获取对象锁的前提下进行。

​				3.yield：这是Thread类的一个静态方法，用于提示调度器当前线程愿意放弃对CPU的占用，以使其他线程得到执行的				机会。然而，yield并不能保证当前线程会立即停止执行，而是使其进入到就绪状态，重新参与CPU的竞争。也就是				说，有可能在yield之后，仍然是该线程获取到CPU并执行。

​				4.join：这是Thread类的一个方法，用于让当前线程等待另一个线程结束后再继续执行。当调用一个线程的join方法				时，当前线程会进入阻塞状态，直到被join的线程执行结束。这种方式常用于确保主线程在所有子线程都完成工作后再				结束。

##### 线程池		

###### 	什么是线程池：

​		线程池的基本思想就是一种对象池，在程序启动的时候，就开辟一块内存空间，里面放入众多线程，线程池中的线程是由池管理		器来进行调度，当有线程任务的时候，从池中选取一个线程去执行任务，执行完后线程再次放入线程池中，避免线程的重复创建		和销毁，节省系统资源

###### 	使用线程池的好处：

​		减少线程的创建和销毁，线程可以被重复利用，可以执行多个任务。

​		运用线程池能有效的控制最大并发数，可以根据系统的承受能力，调用池中的线程，防止因并发过高导致的内存被占满

​		可以对线程进行一些简单的管理，比如延时执行，定时循环执行等等

###### 	线程池的主要组件：

​		线程池管理器：用于创建线程池，包括创建线程池，销毁线程池，添加新任务。

​		工作线程：线程池中的线程，在没有任务时处于等待状态，可以重复利用

​		任务接口：每个任务必须实现的接口，以供线程调度任务的执行

​		任务队列：用于存放没有处理的任务，提供一种缓冲机制

###### 	线程池的核心参数：

​		corePoolSize：核心线程数线程池中维护的最小的一个线程数量，即使这些线程处于空闲状态，那也不会销毁，除非设置了					   allowCoreThreadTimeout

​		maximumPoolSize：最大线程数，线程池所能容纳的最大的线程数量，当活跃线程数达到该数值后，后续的新任务会被阻塞

​		KeepAliveTime：线程池内线程最长空闲时间，一旦超过这个时间，并且当前线程数高于corePoolSize的值，会销毁空闲线程

​		unit：时间单位

​		workQueue：新任务被提交后，会先进入这个队列等待，等待任务调度时才出队执行，采用的是阻塞队列

​		threadFactory：线程工厂，用于定制线程对象的创建，例如设置线程名字，是否是守护线程

​		handler：拒绝策略，当线程池的线程达到maximumPoolSize后，workQueue满了，且当前没有空闲线程，新任务进来后会触				  发拒绝策略

​				AbortPolicy：默认的拒绝策略，线程数量达到max无空闲且workqueue满了，新任务提交后会抛出		         

​							rejectExecutionException

​				CallerRunsPolicy：调用者运行策略，线程数量达到max无空闲且workqueue满了，新任务会提交给调用execute的线								  程执行，适合不允许失败的情况

​				DiscardPolicy：丢弃策略，当达到上述条件，直接丢弃新任务，并且不会抛出异常

​				DiscardOldestPolicy：弃老策略，达到上述条件后，慧丢弃等待时间最长的任务，并尝试提交新任务，如果线程池被								       关闭，则新任务会被丢弃

###### 	线程池类型：

​		FixedThreadPool（制定大小的线程池）

​			线程池内的线程数量固定，即使空闲也不会背回收，当无空闲线程时，新任务会等待

​		ScheduledThreadPool（定时线程池）

​			支持定时或者周期性的执行任务，每个任务都关联一个延时时间，或者周期时间

​			适用于定时任务

​		SingleThreadExecutor（单线程）

​			只有一个线程，所有的任务都会被按照提交顺序执行

​			适合任务之间有关联性的场景

​		CachedThreadPool（可缓存的线程池）

​			线程数量不固定，当提交新任务时，如果线程池中有空闲的线程会立即执行，否则创建一个新线程来执行任务，空闲线程会			在一定时间内销毁，减少资源消耗

​			适用于执行段时间内大量的任务，如用户请求

​		ForkJoinPool

​			Java7引入的一个可以并行拆解任务的线程池，他使用分而治之的策略并行处理大规模计算任务。

​			适用于可以拆解子任务的情况。

##### synchronized

​	原子性：确保线程互斥访问同一段代码

​	可见行：保证共享变量的修改能够及时可见，是通过JMM内存模型来保障的（对一个变量进行unlock之前，必须同步到主内存中，进			行lock之前，需要清空工作内存的变量，重新load一份主内存变量到工作内存）来保证的。

​	有续性：有效解决冲排序问题，即一个lock操作一定先于unlock操作

###### 	基本使用

​		作用于实例方法，锁的是对象的实例

​		作用于静态方法，锁的是Class实例，Class实例只存在于永久代，相当于一个全局锁

​		作用于某个代码块，锁的是括号里的对象实例

###### 	基本原理：

​		依赖于monitorenter和monitorexit两个cpu指令

​		当执行到monitorenter时，会尝试获取monitor的所有权，如果monitor的进入数为0，则该线程进入monitor，然后将进入数		+1，如果该线程已经进入过monitor，只是重新进入，则monitor的进入数+1，如果其他线程已占用monitor，则该线程被阻		塞，知道monitor的进入数为0，再重新尝试获取monitor

​		执行monitorexit的线程必须时拥有monitor的所有权的线程，执行指令的时候，monitor的进入数-1，如果-1后进入数为0，则		线程退出monitor，其他被阻塞的线程则会尝试获取该monitor的所有权

###### 	锁优化（锁升级）

​	锁的状态分4种，无锁、偏向锁、轻量级锁、重量级锁

​	无锁：

​		当前资源没有线程竞争，处于无锁状态

​	偏向锁：

​		有且只有一个线程尝试获取锁，获取成功后，锁对象头的Thread Id会变成当前的线程ID，后续该线程再次尝试获取该锁的时		候，比对Thread Id，发现相同可直接进入同步方法执行。

​	轻量级锁：

​		如果Thread ID不相同，说明有其他线程竞争该锁，那么会检查锁对象中记录的Thread ID是否存活，如果未存活，则该锁重新		被置为无锁状态，线程会通过竞争方式把该锁设置成偏向锁。如果Thread ID的线程是存活的，那么会暂停该线程，升级成轻量		级锁，并且竞争线程通过CAS方式继续尝试，知道达到阈值

​	重量级锁：

​		如果轻量级锁的竞争过于激烈，导致自旋次数过多，那么该锁会升级成一个重量级锁，重量级锁会把所有竞争线程阻塞，方式		CPU空转。

##### volatile

​	保证两个特性

###### 	可见性

​		多线程环境中，当一个线程修改一个volatile变量，这个新值会会被强制刷到主内存中，其他线程读取的时候，被强制从主内存		读取

###### 	有序性

​		volatile能有效防止指令重排序优化，编译器和处理器为了提高性能，常常会对指令顺序进行重排序。然而，这种重排序在多线		程环境中可能会导致问题。`volatile`关键字确保了多线程环境中指令的部分有序性。

​		尽管`volatile`提供了可见性和有序性保证，但它并不保证操作的原子性。因此，尽管`volatile`在某些场景下非常有用，例如		用于状态标记或声明单例，但它并不能完全替代其他的同步机制，如`synchronized`等。

##### ReentrantLock

###### 		作用

​		reeturnentLock支持同一个线程在没释放锁的情况下再次持有锁，并且支持中断，但是必须显示的调用unlock来释放锁，提供		公平锁和非公平锁的实现

###### 		用法

###### 		和synchronized异同

​		当存在大量线程竞争的时候，synchronized升级成重锁，reeturnentLock的性能优于synchronized

###### 		原理

​		ReenturantLock的原理是基于AQS实现的，AQS的核心思想就是如果被请求的共享资源空闲，则把当前的线程置为有效的工作		线程，如果不是空闲的，那么需要一个阻塞队列存储当前被阻塞的线程，等待共享资源空闲后唤醒阻塞队列中被阻塞的线程，		AQS锁被抢占的表示是有一个volatile修饰的state变量来表示的，抢占成功+1，重入+1，不为0代表已经有线程获取锁了，为0代		表为空闲状态

##### 		加锁过程：

​			当第一个线程进来的时候，会尝试使用CAS方式把AQS的state改为1，获取这个锁，此时如果第二个线程进来，尝试CAS获			取锁的时候失败，AQS会初始化一个双向链表，链表中的节点主要存储当前线程，WaitState（初始为0），

##### ReentrantReadWriteLock

​	读写锁，读锁共享，写锁独占，适用于读多写少的场景

###### 	原理

​		底层还是基于AQS实现，还是对state进行操作

​		读操作：基于state的高16位进行操作

​		写操作：基于state的低16位操作

​		写锁重入：也是直接对state的低16位+1即可，只要确认是当前的写锁线程

​		读锁冲入：读锁是共享的，读锁在获取锁资源操作时，是要堆state的高16位进行+1操作。因为读锁是共享锁，所以同一时间会		有多个线程持有读锁资源，为了确认每个线程重入次数，每个读操作的线程都会有一个ThreadLocal记录锁的冲入次数

​		写锁饥饿问题：当前有大量线程占有读锁，一个写锁进来需要等待读锁释放，但是有大量的线程持续获取读锁，导致写锁一直无		法获取，解决方案是获取读锁前判断是否有写锁等待，如果有，则剩余想要获取读锁的线程进入AQS的阻塞队列中即可。

##### ConcurrentHashMap

​	是一个线程安全的hashMap

​	1.7

​		底层是由segment数组+hashentry节点组成的，类似于hashmap的数组+链表，segment对象继承reentrantLock，本身是一把		锁，默认segment数组长度为16，一旦初始化后该数组长度不可改变，只能是hashentry扩容

###### 		put

​			在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果			获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock			（）方法去获取锁，超过指定次数就挂起，等待唤醒

​	1.8

​		摒弃了segement的思想，采用Node+链表/红黑树的底层数据结构，并采用CAS+synchronized来保证并发安全

###### 		put

​			如果没有初始化就先调用initTable（）方法来进行初始化过程

​			如果没有hash冲突就直接CAS插入

​			如果还在进行扩容操作就先进行扩容

​			如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就			按照红黑树结构插入，

​			最后一个如果Hash冲突时会形成Node链表，在链表长度超过8，Node数组超过64时会将链表结构转换为红黑树的结构，			break再一次进入循环

​			如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容

###### 	底层原理

​		底层数据结构大体和HashMap类似，其中原本的hash桶（数组）中存储的不再是entry对象，二十segment对象，一个		segment对象继承reentrantLock，可以加锁，当put一个key-value时，会根据key的hashcode%hash桶的长度，得到index，		是sement数组的index，存储到下标为index的segment的下标中，然后使用segment.lock()方法进行加锁，在根据key的		hashcode%segment对象中的hashentry的长度得到具体的index，这个index是segment对象中的hashentry的index，数据放		完后释放锁即可。

​		如果两个线程同时放K-V，两个Key被hash到不同的segment对象中，这样两者可以同时执行，因为是两个segment（两个		锁），这样就能提高并发量，也就是分段锁的实现

##### ConcurrentLinkedQueue

##### 原子操作类

- `AtomicInteger`：整型原子类
- `AtomicLong`：长整型原子类
- `AtomicBoolean`：布尔型原子类
- `AtomicIntegerArray`：整型数组原子类
- `AtomicLongArray`：长整型数组原子类
- `AtomicReferenceArray`：引用类型数组原子类
- `AtomicIntegerFieldUpdater`:原子更新整型字段的更新器
- `AtomicLongFieldUpdater`：原子更新长整型字段的更新器
- `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段

##### 引用类型

​	强引用：普遍的引用，当一个对象有强引用的时候，垃圾回收就回收不了，即使堆内存不足也不会回收

​	软引用：内存空间充足的时候不会回收，内存不足的时候才回收

​	弱引用：一旦发现是弱引用，不管内存是否充足，直接回收

​	虚引用：形同虚设，和没有引用一样，在任何时候都可能被回收

##### ThreadLocal 

​	ThreadLocal的作用主要是作数据的线程隔离，填充的数据只属于当前线程，在多线程情况下，防止自己的变量被其他线程修改

​	Thread内部有一个ThreadLocalMap类型的map，所有k-v都放入这个map中，所以能做到线程隔离，每次放入key的时候，key就是	当前的ThreadLocal对象，ThreadLocalMap底层是由Entry构成，Entry继承WeakReference

​	`ThreadLocal`的 key 是**弱引用**，那么在 `ThreadLocal.get()`的时候，发生**GC**之后，key 是否为**null**？

​	`ThreadLocal`中`ThreadLocalMap`的**数据结构**？

​	`ThreadLocalMap`的**Hash 算法**？

​	`ThreadLocalMap`中**Hash 冲突**如何解决？

​	`ThreadLocalMap`的**扩容机制**？

​	`ThreadLocalMap`中**过期 key 的清理机制**？**探测式清理**和**启发式清理**流程？

​	`ThreadLocalMap.set()`方法实现原理？

​	`ThreadLocalMap.get()`方法实现原理？

​	项目中`ThreadLocal`使用情况？遇到的坑？



# JVM

### 一个类是什么时候被加载的

​	在《Java虚拟机规》中并没有进行强制约束，交由虚拟机自己掌控，hotspot中是按需加载，在需要用到这个类的时候才会加载。

### jvm中一个类的加载过程

​	一个类加载到jvm内存中，需要经历7个阶段

​		1.加载

​			把classpath， jar包， 网络 ，或者磁盘下的某个class文件二进制字节流读进来，在内存中生成一个代表这个类的			Java.lang.Class对象放入元空间，此阶段我们可以通过自定义类加载器进行干预。

​		2.验证

​			验证class文件中是否符合《Java虚拟机规范》的全部要求，保证虚拟机的安全

​		3.准备

​			类的变量赋默认初始值，int为0，long为0L，boolean为false，引用类型为null，常量正常赋值

​		4.解析

​			把符号引用翻译成直接引用

​		5.初始化

​			当我们new一个对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射对一个类进行调			用，初始化当前类，那么这些都会触发初始化。

​		6.使用

​			使用这个类

​		7.卸载

​			这个类的所有实例都被GC回收

​			加载该类的classLoader被GC

​			该类的在其他类中没有引用	

### jvm中一个类的初始化过程

​	静态成员的初始化

​		静态成员包括静态变量和静态代码块，他们属于类的本身，随着类的初始化而优先被加载。

​		父类中的静态变量和静态代码块

​		子类的静态变量和静态代码块

​		静态成员只加载一次

​	非静态成员初始化

​		非静态成员包含普通变量，普通代码块，一般会在类进行实例话的时候加载

​		父类中的普通成员和普通代码块，然后是构造方法

​		子类中的普通成员和普通代码块，然后是构造方法

### JVM内存模型

##### 	JVM内存模型

​		堆：

​			堆是OOM故障的主要发源地，堆中存储着几乎所有的实例对象，堆由垃圾回收器自动回收，堆区由各个子线程共享使用，			通常情况下，它占用的空间是内存区域中最大的，但是如果无节制的创建对象，会很容易的消耗完所有空间，堆的空间可以			指定大小，也可以运行时动态调整，通过参数 -Xms -Xmx来指定大小。

​		方法区：

​			方法区是所有线程共享的区域，用来存储已被虚拟机加载的类的信息，常量，静态变量，JIT（just in time及时编译技术）			编译后的代码数据，运行时常量池是方法区的一部分区域用于存放编译期间生成的各种字面常量和富豪引用。

​		虚拟机栈：

​			这是一个线程私有的区域，它描述的是Java方法执行的内存模型，每个方法运行的同时，都会创建一个栈帧，栈帧中存储着			局部变量，操作数栈，方法出口等信息。每个方法从调用到完成都对应着栈帧的入栈和出栈。每当方法运行结束后，jvm会			把栈帧出栈的元素当成返回值返回。

​		本地方法栈：

​			本地方法栈和虚拟机栈的作用是相同的，不同的是，本地方法栈只为虚拟机使用到的Native方法执行

​		程序计数器：

​			程序计数器是一块较小堆内存区域，是线程私有的，在多线程环境中，每个线程都有一个程序计数器，用于指示当前线程执			行的字节码地址

### 堆的内存结构划分

​	分为年轻代和老年代，年轻代：老年代 = 1：2

##### 		年轻代：

​			Eden：s0：s1 = 8：1：1

##### 		老年代：	

### 对象的创建过程

​	加载类：通过类的全限定名获取类的二进制字节流，将二进制字节流转换为运行时数据结构，即在方法区创建该类的class对象，作			为方法区该类的入口

​	验证：验证类是否符合JVM规范，确保不会危害JVM

​	准备：为静态变量分配内存并设置类变量的默认值和初始值，

​	解析：将类中的符号引用转换为直接引用，符号引用是编译器生成的，二直接引用和虚拟机的布局有关

​	初始化：为类的静态变量赋予正确的初始值，初始化阶段会在创建类的实例，访问静态变量，调用静态方法，执行反射时触发

### 	类加载器

​		BootStrapClassLoader

​			是ExtClassLoader的父类加载器，负责加载%JAVA_HOME%/lib下的jar包和class文件

​		ExtClassLoader

​			是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext下的jar包和class文件

​		AppClassLoader

​			是自定义加载器的父类加载器，加载classPath下面的类文件

​		可以继承classLoader实现自定义加载器

### 	双亲委托模型

​		从App->Ext->BootStrap从下到上，找缓存，如果已经有加载器加载过该类，则不用加载

​		从bootStrap->Ext->App从上到下找的是加载路径，找到就加载，否则就报找不到类的错误

##### 		好处：

​			安全性， 避免用户自己写的类，替换Java核心类，比如String

​			同时也避免了类的重复加载因为JVM中区分不同类，不仅仅是通过类名相同的class文件被不同的classLoader加载过后就是			不同的类

### 可以打破双亲委托模型吗，怎么做

​	可以，重新定义一个类加载器，重写loadClass方法，使其不进行双亲委派即可

### ClassLoader中loadClass，findClass，defineClass的区别

​	loadClass主要就是进行类加载的方法，其中双亲委派就在这个方法中

​	findClass根据名称或者位置加载class字节码

​	defineClass把字节码转换成class

​	当我们想要自定义一个类加载器，并且想打破双亲模型，需要重写loadClass方法

​	当我们想要自定义一个类加载器，但是不想打破双亲委派模型，可以重写findClass方法，findClass方法之抛出一个异常，没有默认	实现

​	如果想不打破双亲委派模型，且实现自己的类加载器逻辑，可以把相关逻辑方法findClass中即可

### 加载一个类使用Class.forName和classLoader有什么区别

​	Class.ForName得到的class是已经初始化完成的

​	ClassLoader.loaderClass得到的class是没有初始化的

### TomCat类加载的机制

​	在jvm类加载器的基础上，tomcat新增了3个基础类加载器和每个web应用加载器和一个jsp类加载器

### 为什么Tomcat要打破双亲委派模型

​	tomcat是一个web容器，那么一个web容器可能会部署多个应用

###### 			部署在同一个tomcat中的应用所使用的Java类库应该要相互隔离

​			A用的是spring4的jar包， B用的是spring5的jar包，如果没有打破双亲委派，只会加载一遍jar包（可能加载4的也可能是5			的），导致有个应用依赖的jar包不对，打破后，每个wen应用都有自己的类加载器，都加载自己的jar包

###### 			部署在同一个tomcat中的应用所使用的Java类库应该要相互共享

​			一些版本相同的jar包可以共享，比如json，jdbc。。。。

###### 			保证tomcat服务器自身的安全不受部署web应用程序的影响

​			tomcat的类加载器加载tomcat需要的类，web应用的类加载器加载web应用需要的类，不要相互打扰

###### 			需要支持jsp页面的热部署和热加载

​			tomcat支持jsp热加载，只需要替换原来的jsp后，tomcat就会启动一个新的类加载器重新加载jsp

### 说一下对象完整的创建流程

​	1.类加载检查：

​		当虚拟机执行 new Objects。。。代码的时候， 会先到常量池中检查是否有当前类的引用，如果这个类没有被加载，解		析初始化，JVM会进行类的加载过程

​	2.内存分配：

​		一旦类加载检查通过，JVM会为新对象分配内存。这个内存大小在类加载完成以后就会确定，内存分配主要有两种方式，指针碰		撞 和 空闲列表，在指针碰撞中， JVM认为Java虚拟机中内存是完整的，已使用的内存在一边， 另一边时未使用的内存，以指针		为分界线，分配内存时只需要把指针向空闲内存移动即可

​	3.初始化零值：

​		分配完内存后，JVM会将对象的内存空间初始化零值，确保对象即使没有显示的赋初值，也可以安全的使用

​	4.设置对象头：

​		接下来，JVM会对对象进行一些必要的设置，这些信息存储在对象头中，包括对象的hashcode，GC分代年龄，所属的类，类的		元数据信息等等。

​	5.执行构造函数：

​		最后，JVM会调用开发人员定义的构造函数，对对象进行初始化。这个过程包括调用父类的构造函数，成员变量的显示初始化，		构造代码块的初始化，

### 对象内存分配时的指针碰撞和空闲列表机制

​	指针碰撞：

​		是一种简单的内存分配策略，通常用于具有固定大小对象的堆，这种策略下，堆被分为两个区域，已分配区域和未分配区域，一个指针指向未分配区		域的开始，当需要分配一个新对象的时候，该指针简单的移动就能给出足够的内存空间

​		优点是分配速度快，适用于对象大小固定的堆。

​		缺点是不适合动态大小的对象，

​	空闲列表

​		维护一个链表。其中包含堆未使用的内存信息，当需要分配一个对象的时候，分配器会找到一个适合的空间，并在链表中删除该信息，如果没有找到会尝		试合并

### 对象头

​	对象在内存中的布局分为三部分，对象头，实例数据，对其信息。

​	对象头包含两部分信息

##### 		markWord

​			大小占4个字节，用于存储对象的hashcode，分代年龄，锁类型，持有锁的线程ID，

##### 		Class对象指针

​			Class Pointer则用来指向生成该对象所在的类，即对象的类型指针，指向它的类元数据。如果是数组对象，对象头还会包含Array Length（数组长			度）这一信息。

### 如何计算对象占用内存大小

​	

### 对象指针压缩

##### 	原因

​		32位系统的内存最多使用4g，原因是和内存寻址有关，内存是按照字节位单位进行编址的，每个字节都有一个唯一的内存地		址，这个地址是一个32位的二进制数，可以表示2的32次幂个不同地址，即4g地址空间，所以32位系统的内存寻址最大为4g

​		32位系统的对象指针是4字节，64位系统的对象指针是8字节，导致对象指针占用的内存空间变大，因此间接的导致了GC的频繁		发生，GC次数越多，导致占用CPU的时间越多，造成系统响应变慢，吞吐量降低。

​		对象的引用变大了，那么CPU的缓存对象就少了，造成CPU缓存的命中率下降，需要去访问内存，访问内存的效率比访问CPU缓		存的效率低，会降低CPU执行效率，增加响应时间，从而影响性能。

##### 	方法

​		对象都是以8字节对齐方式即对象的大小都是8的倍数，所以无论32位还是64位的二进制表示，末尾3位表示都是0，那么这些无		意义的0可以利用起来，比如说寻址的时候左移三位补充0，存储的时候右移三位舍去0，这样一来，可存储的指针变多。

### 解释下对象栈上分配，逃逸分析标量替换

​	上述全是JVM的优化技术，用于提高程序的性能和内存使用效率

##### 	对象栈上分配

​		在Java中，对象通常是在堆中分配，因为Java堆是对象的主要存储区域，然而，对于某些生命周期很短，作用域很小的对象来		说，在栈汇总给他们分配空间将大大提升内存分配和回收速度，因为栈内存分配和回收是自动而且速度很快。

​		JVM通过逃逸分析来判断一个对象是否可以在栈上分配内存，如果一个对象的作用域被限制在方法内，并没有被外部引用，那么		它就可以在栈上分配使用，当方法执行完毕后，会跟随栈帧被销毁

##### 	逃逸分析

​		逃逸分析是JVM用于判断对象是否可能被外部方法访问或引用的过程。如果一个对象可能被外部方法引用，那么它就不能在栈上		分配，因为栈帧销毁时，栈上的对象也会随之销毁，这会导致外部引用失效。

​		逃逸分析的结果决定了对象是否可以在栈上分配。如果对象没有逃逸出方法，那么它就可以在栈上分配；否则，它必须在堆上分		配。

##### 	标量替换

​		标量替换是另一种优化方式，如果一个对象中只有一个字段被外部引用，那么可以把这个字段分离出来，直接存储到栈上或者当		成一个局部变量，这样原本的对象就不再需要了，从而减少堆内存的使用。

### 什么样的类能被回收

##### 	没有任何引用的对象

​		当一个对象没有任何引用，他就无法被程序访问到，那么就可以回收。

##### 	超出作用域的对象

​		局部作用域创建的对象，当方法执行完毕后，如果这些对象没有外部引用，那么就可以回收

##### 	显式的解除引用的对象

​		当程序设置对象的引用位null时，就可以回收

##### 	匿名内部类和lambda表达式创建的实例

​		如果这些实例被创建后，没有被任何引用持有，那么就可以回收

##### 	循环引用的但是无法到达GC ROOT根的对象

​		两个对象相互引用，导致引用计数器不为0，但是通过可达性分析算法，如果判断到底GC ROOT没有任何引用链，就能被回收

### CMS垃圾收集器收集过程

##### 	初始标记阶段

​		在此期间，CMS会暂停所有用户线程，执行STW操作，通过可达性分析标记处所有和GC Root 有引用链的对象

##### 	并发标记阶段

​		初始标记完成后，CMS慧恢复用户线程同时CMS会并发的对堆内存标记，慧标记出和初始标记中存活对象有关联的对象，由于		是并发执行，CMS会忽略那些被应用程序修改的对象，以确保标记的准确性

##### 	重新标记阶段

​		并发标记完成后，CMS会再次停止所有用户线程，执行STW，这个阶段的目的是修复并发标记期间因用户线程执行而修改的标		记变动（如错标漏标），重新扫描堆空间，标记出并发标记阶段有用户线程修改而存活的对象

##### 	并发清除阶段

​		标记结束后，JVM恢复所有用户线程，CMS开始对垃圾对象进行回收

​		由于是基于标记清除算法，所以不需要移动对象

​		此操作是并发执行，不会停顿用户线程

### CMS比较严重的问题，并发收集阶段再次触发Full GC怎么处理

​	减少Full GC发生的频率

### 垃圾收集底层三色标记法

##### 	工作原理

​		初始阶段

​			该阶段，所有的对象都被置为白色，表示他们还没有被垃圾收集器访问过，同时GC Root被标记成黑色，

​		标记阶段

​			垃圾收集器从GC Root出发，遍历对象引用链，当一个白色对象被黑色对象引用时，会被标记成灰色，表示该对象被访问			过，但是其子对象还没被访问过，然后垃圾收集器会遍历灰色对象的子对象，将其中的白色标记为灰色，如此反复，直到没			有灰色对象出现。

​		回收阶段

​			回收所有白色对象

### 对象漏标的处理方案 增量更新与原始快照

​	主要是解决并发标记的时候，由于用户线程执行造成的漏标问题

##### 	增量更新

​		增量更新方案关注的是引用的增加，在并发标记过程中，当发现黑色对象增加了对白色对象的引用时，把这个新引用记下来，并		在重新标记阶段进行处理，这样在并发标记阶段结束后，白色对象看似没有被引用，但由于增量更新存在，这些对象还有可能被		正确标记，CMS就采用这个方案

##### 	原始快照

​		该方案关注的是删除的引用，在并发标记开始的时候，对整个对象图生成一个快照，几率下当时所有的引用关系，在并发标记开		始时，如果灰色对象对白色对象的引用消失，那么这个消失的引用会被推送到垃圾收集器的堆栈中，来保证白色对象在后续的扫		描中能被扫描到，G1使用这个方案

### G1的垃圾收集过程

##### 	并行与并发

​		在G1回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，它拥有与用户线程交替执行的能力，部分工作可以和用		户线程同时执行，因此不会在回收阶段阻塞用户线程。

##### 	区域划分

​		G1把堆空间划分为多个大小相同的区域，每个区域进行独立的垃圾回收，这种情况控制了G1只能选择部分区域进行回收，很好		的控制了全局停顿的情况发生

##### 	分代收集

​		G1属于分代收集器，会区分年轻代和老年代，年轻代包括Edan S区，G1会采取不同的方式去处理新对象以及经历过多次GC的		对象。

##### 	标记-复制/整理

​		G1从整体上看，是基于标记-整理算法，但是从局部看（年轻代），也是存在复制算法，这两种算法的结合意味着不会出现内存		碎片。

##### 	对象标记与转移

​		在每个区域中，G1标记处存活的对象和垃圾对象，对于存活对象，将会拷贝到空闲的区域中，同时更新其原始引用，最后清除		所有垃圾对象，释放内存空间。

##### 	可预测的停顿时间模型

​		G1除了追求低停顿之外，还建立了可预测停顿时间的模型，可以指定在一个长度为M的时间内，垃圾收集不得超过N时间，使得		G1在有限时间内尽量提高效率。

### G1垃圾收集最大停顿时间如何实现的

1. **基于Region的内存布局**：G1将Java堆划分为多个大小相等的独立区域（Region），这使得它能够优先处理垃圾对象数量多或大小大的区域，从而更有效地进行垃圾回收。这种布局方式使得G1能够控制每次垃圾收集的范围，有助于减少全局停顿时间。
2. **停顿时间模型**：G1建立了停顿时间模型，该模型允许用户指定一个目标停顿时间，即在一个特定的时间片段内，垃圾收集所消耗的时间不超过设定的阈值。G1会根据这个目标停顿时间来选择相应的区域进行垃圾回收，以满足用户的性能需求。
3. **并行与并发**：G1充分利用多核CPU的硬件优势，使用多个GC线程并行执行垃圾收集任务。这种并行处理的方式能够加快垃圾收集的速度，从而减少停顿时间。同时，G1还采用并发的方式，让垃圾收集线程与应用程序线程交替执行，减少了对应用程序的干扰。
4. **增量更新与SATB**：G1采用增量更新或SATB（Snapshot At The Beginning）等机制来处理对象漏标问题。这些机制能够确保在并发标记过程中，新产生的垃圾对象或丢失的引用关系能够被正确处理，从而避免了因对象漏标而导致的额外停顿时间。
5. **连续运行与内存碎片整理**：在满足用户定义的停顿时间基础上，G1会连续运行以减少内存碎片。每次垃圾收集时，G1都会把对象从一个或多个区域复制到另一个区域，并进行内存整理和释放。这种疏散过程在多处理器上并行执行，以减少停顿时间并增加吞吐量。

### 什么是内存泄露，如何排查

​	是指在程序运行过程中，动态分配的内存没有得到及时释放，导致系统无法再为其它对象分配内存，或者导致系统内存耗尽的现象。	内存泄漏并非指物理内存的消失，而是指程序在申请内存后，未能正确地释放已申请的内存空间，从而使得这部分内存无法被再次使	用。

### GC是什么时候都能做的吗，GC安全点和安全区域

​	GC（垃圾收集）并不是随时都可以进行的。为了保证垃圾收集过程的安全性和效率，JVM（Java虚拟机）引入了安全点和安全区域的	概念。

​	安全点是指在程序执行过程中的一些特定位置，在这些位置上，所有工作线程的状态是确定的，JVM可以安全地执行GC。这些位置通	常是由JVM选择的，它们是一些记录线程调用栈、寄存器等重要数据区域的地方，这些区域包含了GC需要管理的指针（对象引用）。	通过访问这些记录（通常通过OopMaps结构），GC可以知道哪些对象引用是活跃的，从而可以安全地回收不再被引用的对象。

​	安全区域则是与安全点相对应的概念。在垃圾收集期间，当线程运行到安全点时，它们会被挂起（stop-the-world），以便JVM进行	GC操作。但是，在某些情况下，线程可能长时间运行而不进入安全点，例如，当线程处于Sleep状态或Blocked状态时。为了处理这	种情况，JVM会设置一些安全区域，在这些区域内，线程是允许继续执行的。当JVM开始GC时，会要求所有线程尽快进入最近的安全	点。如果线程处于安全区域内并且无法在要求的时间内进入安全点，那么它们将被挂起，直到GC完成。

​	总的来说，GC并不是随时都可以进行的，它需要在安全点或安全区域进行，以确保垃圾收集过程的安全性和效率。同时，JVM会尽量	优化GC的执行，减少stop-the-world的发生，以提高程序的性能。

### 字符串常量池

### 八种基本类型的包装类常量池如何实现的

### 热加载和热部署

##### 	热加载

​		在不重启服务的情况下，使得修改的代码生效，热加载可以显著提升开发调试效率，但是不安全，不会上生产

​		如何实现：

​			实现自己的类加载器

​			从自己的类加载器中加载需要热加载的类

​			不断轮询需要热加载的类，判断class是否有更新，如果有更新，重新加载

##### 	热部署

​		在不重启服务的情况下，重新部署整个项目，tomcat就是热部署，如果修改war包内容，tomcat就会删除之前的war包，重新生		成一个新的war包

### GC垃圾回收算法

##### 	引用计数器法

​		每个对象个都有一个引用计数器，当对象被引用，计数器加1，引用结束，计数器减1，为0的时候，就可以被回收

​		优点是简单，缺点是无法处理循环引用

##### 	标记清除算法

​		先把存活的对象标记出来，然后删除垃圾对象，缺点是容易导致出现内存碎片，效率低

##### 	复制算法

​		把内存区域划分成两部分，每次只用一半，把存活的对象移到另一边即可，不会出现内存碎片，缺点是内存使用率低

##### 	标记压缩

​		在经过标记后，把存活的对象移动到一端，然后以存活的分界线直接丢弃另一端的垃圾对象，优点是解决了内存碎片的问题，提		高内存的使用率，缺点是需要移动对象，增加性能开销

##### 	分代回收

​		根据年轻代和老年代的对象存活以及GC特点，年轻代使用复制算法，老年代使用标记压缩算法

##### 	增量式垃圾回收

​		用户线程和垃圾线程交替执行，减少STW（stop the word）导致的停顿时间，该算法适用于对与性能要求较高的系统

### GC垃圾收集器

##### 	串行垃圾收集器

​		在收集垃圾时，暂停所有用户线程，直到收集完成

​		适用于单线程环境或者系统规模较小

##### 	并行垃圾收集器

​		使用多线程并行进行垃圾回收，但是用户线程依然被暂停

​		适用于多核CPU，可以缩短垃圾回收时间

##### 	并发标记-清除收集器

​		在垃圾收集过程中，用户线程和垃圾回收线程可以并发执行，减少STW时间

​		适用于对系统响应时间有一定要求的系统

##### 	G1收集器（Garbage first）

​		将对内存划分多个大小相同的区域，优先收集垃圾最多的区域，尽可能满足应用的停顿时间要求

##### 	ZGC收集器

​		实现低延迟的垃圾收集器，几乎不产生停顿

​		对实时性能要求特别高，游戏或者实时交易系统

##### 	Shenandoah收集器

​		基于标记-压缩算法，设计用于降低停顿时间，支持并发和并行操作

​		大规模，高吞吐系统

##### 	Epslion收集器

​		不执行任何垃圾收集，如果对堆存满了，直接停止应用

​		适用于某些性能测试

### 	GC如何判断对象可以被回收

​		引用计数法

​			每个对象都有一个计数器，如果被引用一次，则计数器加一，引用释放则计数器减一，如果计数器为0，代表可以被回收

​			如果a引用b，b又引用a，则引用无法被释放，不可被回收

​		可达性分析法

​			从GC Root向下搜索，搜索走过的路径称之为引用链，如果一个对象到GC Root没有任何引用链，则证明此对象是没有用			的，可回收

​			GC Root对象有：

​				虚拟机栈中引用的对象

​				方法区中静态属性引用的对象

​				方法区中常量引用的对象

​				本地方法栈中引用的对象

​				被可达性分析标记的可回收对象拥有一次不被回收的机会，对象被回收需要经过两次标记，第一次是GC Root可达性分				析标记出没有引用链，第二次是由虚拟机栈自动建立的Finalizer队列中判断是否执行finalize方法

​				当对象不可达时，GC会判断当前对象是否覆盖finalize方法，没有覆盖就会被回收，覆盖了，否则，判断兑现过是否执				行过finalize 方法没执行过，就放入F-queue队列，由低优先级的线程执行该队列中的finalize方法执行完后，GC再次				判断队列中的对象是否可达，不可达会被回收，否则不会回收。

# MySQL



# Redis

# MyBatis

# Spring

### Spring启动流程

​	

### 	如何定义一个IOC容器

​		1.配置包的扫描路径

​		2.递归包扫描获取.class文件

​		3.反射，确定需要交给IOC的类

​		4.对需要进行依赖注入的类进行依赖注入

​			配置文件中指定需要扫描包的路径

​			定义一些注解，分别表示控制层，业务层，数据持久层，依赖注入注解，获取配置文件注解

​			从配置文件中获取扫描包的路径，获取当前路径下的所有.class文件，把当前所有.class文件放入Set集合中

​			遍历这个Set集合，获取在类上有指定注解的类，并交给IOC容器，定义一个安全的map来存储这些对象

​			遍历这个IOC容器，获取每一个类的实例，判断是否有依赖注入，如果有，就进行依赖注入

# SpringBoot

### 常用注解以及实现原理

##### 	@SpringBootApplication

​		这个注解是一个组合注解其中包含以下主要注解

​		@SpringBootConfiguration

​			该注解也是一个组合注解，包含@Configuration注解，主要作用是，标注该类为配置类，spring启动的时候扫描含有该注			解的类，并生成对应的BeanDefination存入到IOC容器中

​		@EnableAutoConfiguration

​		@ComponentScan

​	@EnableAutoConfiguration

​	@Configuration

​	@ComponentScan

​	@Service

​	@Repository

​	@Controller

​	@Bean

​	@Import

​	@Condition

### 自动装配

​	自动装配是springboot会把一些配置类的bean注册到IOC容器中，开发者必须要引入相应的包，无需关心其他配置细节，由	      	springboot默认帮我们配置好，要使用的时候直接注入使用即可

### 启动流程

