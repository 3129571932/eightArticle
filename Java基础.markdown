# Java基础



### 面向对象

##### 	什么是面向对象

​		对比于面向过程，是两种不同的处理问题的方式

​			面向过程是一个更注重于解决事情的每一个步骤和顺序，面向对象更注重于事情有哪些参与			者，及各自需要做什么。

​			比如：洗衣机洗衣服

​			面向过程会把这件事拆解成一系列的步骤（函数），1-打开洗衣机--->2-放衣服--->3-放洗衣			粉--->4-清洗--->5-烘干

​			面向对象会拆出人和洗衣机两个对象

​			人：打开洗衣机，放衣服，放洗衣粉

​			洗衣机：洗衣服，烘干

​		从以上例子能看出，面向过程更高效，面向对象更易于复用和维护

##### 	面向对象的特点

###### 		封装

​			意义在于明确表示同意出允许外部使用的函数和属性

​			内部实现细节对外部隐藏，外部调用无需修改或者关心内部的实现

​			类似JavaBean，对外只提供get和set方法去操作属性，或者orm框架，不用关心如何建立连			接，sql怎么执行，只需要引入mybatis，调用方法即可

###### 		继承

​			继承父类的方法，并做出自己的改变或者扩展

​			子类共性的方法或者属性直使用父类的，无需重新定义，只需要扩展自己个性化的

###### 		多态

​			实现多态需要，继承父类，重写父类的方法，父类的引用指向子类的实例，就导致同一个方			法有不同的执行或者结果



### JDK JRE JVM之前的区别

##### 	JDK

​		Java Development Kit（Java开发工具包），开发Java程序必要的

##### 	JRE

​		Java Runtime Environment（Java运行时环境），只运行Java程序，可以装这个

##### 	JVM	

​		Java Virtual Machine（Java虚拟机），通过javac把Java文件编译成class文件，JVM执行class文		件

​	总结：

​		JDK包含JRE，JRE包含JVM



### ==和equals

##### 	==：

​		对比的是栈中的值，对于基本数据类型来说，比较的是变量的值，队医引用类型来说，比较的是		堆内存中的对象地址

##### 	equals：

​		object中的equals方阿福默认使用==来比较，通常会重写这个方法



### 常量池



### final

##### 	final作用

​		标识类，代表该类不能被继承

​		标识属性，代表这个属性所指向的内存地址不可变

​		标识方法，代表该方法不可被重写（子类继承父类，重写方法），但是可以重栽（一个类多个相		同的方法名）

​		（1）修饰成员变量

​			如果修饰的是static类型的类变量，必须在初始化时赋值或者在静态代码块中赋值

​			如果修饰的是成员变量，可以在非静态代码块，声明变量时候，或者构造器中赋值

​		（2）修饰局部变量

​			系统不会为局部变量进行初始化，局部变量(方法内部变量)必须由人进行显式初始化，所以			可以在定义时指定默认值，也可以不指定默认值，在后面的代码中对final局部看量赋初值。

​		（3）修饰基本类型和引用类型数据

​			如果是基本类型，在初始化后不能更改

​			如果是引用类型，初始化后不能修改指针指向别的对象，可以修改引用的值

##### 	为什么局部内部类和匿名内部类只能访问局部final变量

​		首先需要明确的是，内部类和外部类处于同一个级别，内部类不会因为定义在方法中就会随着犯		法的执行完毕就被销毁。

​		这里就会有问题，当外部类的方法执行完毕后，局部变量就会被销毁，但是内部类的对象可能还		存在，这就产生一个矛盾，内部类对象访问一个被销毁的局部变量，就会报错，为了解决这个问		题，就把局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访		问他，实际上访问的是局部变量的copy。

###### 		将局部变量赋值为内部类的成员变量时，必须保证两个变量是一样的，也就是说我们在内部类中		修改了成员变量，方法中的局部变量也会跟着变，怎么解决这个问题

​		将局部变量设置为final，初始化后，不再能被修改，就能保证一致性



### String StringBuilder StringBuffer区别及使用场景

##### 	String

​		String底层时final修饰的char数组，不可变，每次操作都会产生新的String对象

##### 	StringBuilder

​		StringBuilder事在原对象中作修改

##### 	StringBuffer

​		StringBuffer在原对象中作修改，而且方法都是用synchronized修饰，线程安全

##### 	总结：

​		性能方面：

​			StringBuilder > StringBuffer > String

​		经常修改推荐使用StringBuilder，有多线程并发的情况使用StringBuffer，String适合常量



### 重载和重写的区别

##### 	重载

​		重载是发生在同一个类中，方法名必须相同，参数的类型个数顺序不同，方法的返回值和访问修		饰符可以不同，发生在编译的时候。

##### 	重写		

​		发生在父子类继承关系的时候，方法名和参数列表必须相同，异常范围小于等于父类，访问修饰		符大于等于父类，如果父类的方法是private修饰的不能被继承



### 接口和抽象类

##### 	 抽象类

​		可以存在普通成员函数

​		可以有任何类型的成员变量

​		只能单继承

​			抽象类的设计目的是为了代码复用，当发现多个类有相同的方法实现的时候，就可以把这个			方法抽象到一个新的抽象类中，在新的抽象类中实现该方法，各个类继承这个抽象类，也就			达到了代码复用的效果

##### 	 接口

​		只能存在抽象方法

​		成员变量只能是public static final类型的

​		可以多实现

​			接口设计的目的，是为了约束类的行为（更准确的来说应该是约束类“有”这个行为），也就			是说，强制实现该接口的类都要有类似的行为，但是不能强制行为实现的细节。



### List和Set区别

##### 		List

​		有序，按照对象add的顺序保存对象，可以重复，允许有多个null元素，可以使用Iterator迭代器		取出所有元素在逐一遍历，还可以使用get（index）获取指定位置的元素，对于随机访问支持友		好

##### 	Set

​		无序，不可重复，最多允许有一个null元素，获取元素只能使用Iterator接口获取所有元素，在逐		一遍历各个元素



### HashCode和equals

##### HashCode

​		作用是返回当前对象的哈希码，主要用于快速定位该对象在哈希表中的索引位置

##### equals

​		equals是Object对象中定义的方法，默认使用==比较当前对象和目标对象是否相同，String，Integer等		等对象重写了该方法，改成了值等的比较，配合hashcode来确保对象在hashmap中的唯一性



### 为什么重写equals必须要重写hashcode

​		equals默认是==比较，对于基本类型来说是比较值是否相等，对于引用类型来说是比较指向的内存地址		是否相等，如果重写equals，改变了对象比较的规则（逻辑相等），hashcode，如果两个对象相等，我		们期望hashcode要相同，但是我们改变了equals方法，逻辑相等，但是对象的内存地址不一定相等，造		成hashcode不相等，肯能两个逻辑相同的对象存储到不同的hash-bucket中，所以我们要改变hashcode		的实现，改成属性为参数。



### ArrayList和LinkedList的区别

##### 		1.数据结构

​			在数据结构上，ArrayList和LinkedList都是线性表，都继承于Java中的List接口。另外LinkedList还			实现了Java中的Deque接口，是基于链表的栈或者队列，与之对应的是ArrayDeque基于数组的栈或			者队列。

##### 		2.线程安全

​			ArrayList和LinkedList都不考虑线程同步，不保证线程安全。

##### 		3.底层实现

​			在底层实现上，ArrayList是基于动态数组的，而LinkedList是基于双向链表的，这导致他们的特性			上有所不同，比如

##### 				遍历速度：

​					数组是一块连续的内存空间，对于遍历支持友好，而链表是分散的内存空间，对于遍历访					问不友好

##### 				随机访问：

​					数组有下表index索引，对于随机访问能做到O（1）的时间复杂度，而链表只能从头节点					循环往后遍历查询比对，时间复杂度为O（n）

##### 				添加删除：

​					数组如果在尾部进行添加删除只需要O（1）的时间复杂度，如果在中间进行添加删除，需					要搬运数组，需要O（n）的时间复杂度，链表本身有前后指针可以修改指向对象，所以只					需要O（1）的时间复杂度

##### 				额外内存消耗：

​					数组需要预先给出空间，而链表是动态扩容的

### HashMap和HashTable区别

##### 1.数据结构

​			两者都是实现Map接口，HashMap和HashTable都是由散列表构成，数组（bucket）+ 链表构成

##### 2.线程安全

​			HashTable是线程安全的，synchronized修饰方法，但是HashMap效率高于HashTable

##### 3.其他

​			HashMap允许key或者value为null，HashTable不允许



### 创建线程的几种方式

​	1.继承Thread类，重写run方法。调用实例的start方法开启线程

​	2.实现Runnable接口，重写run方法，调用start方法开启线程

​	3.实现callable接口，结合Future实现，callable实现类作为参数传递给FutureTask的构造参数，FutureTask	作为构造参数传递给Thread作为构造参数，然后调用strat开启线程

​	4.通过线程池创建线程



### 线程的生命周期

​	1.新建状态，是刚用new方法，new出来的线程对象

​	2.就绪状态，是线程调用strat方法后，这个时候线程数语就绪态，等待CPU资源的分配

​	3.运行状态，就绪态的线程获取到了CPU的时间轮询，开始执行

​	4.阻塞状态，在运行的时候，可能由于某些原因导致运行状态的线程变成了阻塞状态

​	5.等待状态，线程调用wait或者join方法，进入等待状态，或者CPU时间轮询分片使用结束

​	6.死亡状态，线程正常执行完毕后着被提前强制终止或者出现异常导致结束，线程会被销毁



### 线程池的核心参数

##### 	1.corePoolSize

​		核心线程数，创建以后，会一直存活到线程池销毁，空闲时也不销毁。

##### 	2.maximumPooSize

​		最大线程数，线程池允许创建的最大线程数量，阻塞队列满了

##### 	3.keepAliveTime

​		空闲线程的存活时间，当线程池中一些没有任务的空闲线程存活一定时间后，就会销毁改线程

##### 	4.TimeUnit

​		空闲线程存活时间的时间单位，

##### 	5.BlockingQueue

​		线程池的任务队列

​			ArrayBlockingQueue：由数组构成的有界阻塞队列

​			LinkedBlockingQueue：由链表构成的有界阻塞队列

​			SynchronousQUeue：一个不存储元素的阻塞队列，直接提交给线程不保持它们

​			PriorityBlockingQueue：一个支持优先级排序的无界队列

​			DelayQueue：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素

​			LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含			有非阻塞方法。

​			LinkedBlockingQueue：一个由链表构成的双向阻塞队列

##### 	6.ThreadFactory

​		创建线程的工厂

##### 	7.RejectedExecuitionHandler

​		拒绝策略

​			AbortPolicy：拒绝并抛出异常。

​			CallerRunsPolicy：使用当前调用的线程来执行此任务。

​			DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。

​			DiscardPolicy：忽略并抛弃当前任务。

### 线程池的运行原理

​		

