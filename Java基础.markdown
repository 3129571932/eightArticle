# Java基础



### 面向对象

##### 	什么是面向对象

​		对比于面向过程，是两种不同的处理问题的方式

​			面向过程是一个更注重于解决事情的每一个步骤和顺序，面向对象更注重于事情有哪些参与			者，及各自需要做什么。

​			比如：洗衣机洗衣服

​			面向过程会把这件事拆解成一系列的步骤（函数），1-打开洗衣机--->2-放衣服--->3-放洗衣			粉--->4-清洗--->5-烘干

​			面向对象会拆出人和洗衣机两个对象

​			人：打开洗衣机，放衣服，放洗衣粉

​			洗衣机：洗衣服，烘干

​		从以上例子能看出，面向过程更高效，面向对象更易于复用和维护

##### 	面向对象的特点

###### 		封装

​			意义在于明确表示同意出允许外部使用的函数和属性

​			内部实现细节对外部隐藏，外部调用无需修改或者关心内部的实现

​			类似JavaBean，对外只提供get和set方法去操作属性，或者orm框架，不用关心如何建立连			接，sql怎么执行，只需要引入mybatis，调用方法即可

###### 		继承

​			继承父类的方法，并做出自己的改变或者扩展

​			子类共性的方法或者属性直使用父类的，无需重新定义，只需要扩展自己个性化的

###### 		多态

​			实现多态需要，继承父类，重写父类的方法，父类的引用指向子类的实例，就导致同一个方			法有不同的执行或者结果



### JDK JRE JVM之前的区别

##### 	JDK

​		Java Development Kit（Java开发工具包），开发Java程序必要的

##### 	JRE

​		Java Runtime Environment（Java运行时环境），只运行Java程序，可以装这个

##### 	JVM	

​		Java Virtual Machine（Java虚拟机），通过javac把Java文件编译成class文件，JVM执行class文		件

​	总结：

​		JDK包含JRE，JRE包含JVM



### ==和equals

##### 	==：

​		对比的是栈中的值，对于基本数据类型来说，比较的是变量的值，队医引用类型来说，比较的是		堆内存中的对象地址

##### 	equals：

​		object中的equals方阿福默认使用==来比较，通常会重写这个方法



### 常量池



### final

##### 	final作用

​		标识类，代表该类不能被继承

​		标识属性，代表这个属性所指向的内存地址不可变

​		标识方法，代表该方法不可被重写（子类继承父类，重写方法），但是可以重栽（一个类多个相		同的方法名）

​		（1）修饰成员变量

​			如果修饰的是static类型的类变量，必须在初始化时赋值或者在静态代码块中赋值

​			如果修饰的是成员变量，可以在非静态代码块，声明变量时候，或者构造器中赋值

​		（2）修饰局部变量

​			系统不会为局部变量进行初始化，局部变量(方法内部变量)必须由人进行显式初始化，所以			可以在定义时指定默认值，也可以不指定默认值，在后面的代码中对final局部看量赋初值。

​		（3）修饰基本类型和引用类型数据

​			如果是基本类型，在初始化后不能更改

​			如果是引用类型，初始化后不能修改指针指向别的对象，可以修改引用的值

##### 	为什么局部内部类和匿名内部类只能访问局部final变量

​		首先需要明确的是，内部类和外部类处于同一个级别，内部类不会因为定义在方法中就会随着犯		法的执行完毕就被销毁。

​		这里就会有问题，当外部类的方法执行完毕后，局部变量就会被销毁，但是内部类的对象可能还		存在，这就产生一个矛盾，内部类对象访问一个被销毁的局部变量，就会报错，为了解决这个问		题，就把局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访		问他，实际上访问的是局部变量的copy。

###### 		将局部变量赋值为内部类的成员变量时，必须保证两个变量是一样的，也就是说我们在内部类中		修改了成员变量，方法中的局部变量也会跟着变，怎么解决这个问题

​		将局部变量设置为final，初始化后，不再能被修改，就能保证一致性



### String StringBuilder StringBuffer区别及使用场景

##### 	String

​		String底层时final修饰的char数组，不可变，每次操作都会产生新的String对象

##### 	StringBuilder

​		StringBuilder事在原对象中作修改

##### 	StringBuffer

​		StringBuffer在原对象中作修改，而且方法都是用synchronized修饰，线程安全

##### 	总结：

​		性能方面：

​			StringBuilder > StringBuffer > String

​		经常修改推荐使用StringBuilder，有多线程并发的情况使用StringBuffer，String适合常量



### 重载和重写的区别

##### 	重载

​		重载是发生在同一个类中，方法名必须相同，参数的类型个数顺序不同，方法的返回值和访问修		饰符可以不同，发生在编译的时候。

##### 	重写		

​		发生在父子类继承关系的时候，方法名和参数列表必须相同，异常范围小于等于父类，访问修饰		符大于等于父类，如果父类的方法是private修饰的不能被继承



### 接口和抽象类

##### 	 抽象类

​		可以存在普通成员函数

​		可以有任何类型的成员变量

​		只能单继承

​			抽象类的设计目的是为了代码复用，当发现多个类有相同的方法实现的时候，就可以把这个			方法抽象到一个新的抽象类中，在新的抽象类中实现该方法，各个类继承这个抽象类，也就			达到了代码复用的效果

##### 	 接口

​		只能存在抽象方法

​		成员变量只能是public static final类型的

​		可以多实现

​			接口设计的目的，是为了约束类的行为（更准确的来说应该是约束类“有”这个行为），也就			是说，强制实现该接口的类都要有类似的行为，但是不能强制行为实现的细节。



### List和Set区别

##### 	List

​		有序，按照对象add的顺序保存对象，可以重复，允许有多个null元素，可以使用Iterator迭代器		取出所有元素在逐一遍历，还可以使用get（index）获取指定位置的元素，对于随机访问支持友		好

​	Set

​		无序，不可重复，最多允许有一个null元素，获取元素只能使用Iterator接口获取所有元素，在逐		一遍历各个元素

